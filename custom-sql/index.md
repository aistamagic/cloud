# Custom SQL

Sometimes you need more complex abilities than your automatically generated endpoints can
give you. You can do this by editing the file directly from your Magic dashboard using the
_"Files"_ menu item. This works kind of like a file explorer, allowing you to traverse your
file system, on your server, to modify your files.

Open up whatever endpoint file you want to modify, edit it using the integrated Hyperlambda
CodeMirror editor, and save it. The endpoint will immediately change its behaviour. No
compilation process is required. Below is an example of such a file that was automatically
generated by the _"Crudifier"_. Notice, I have added comments to the file, which is not
done by the _"Crudifier"_ in order to make it more easily understood.

```
/*
 * Declares the input arguments this HTTP endpoint accepts.
 */
.arguments
   limit:long
   offset:long
   order:string
   direction:string
   id:long
   role:string


/*
 * Verifies the user belongs to the "root" role.
 */
auth.ticket.verify:root


/*
 * Applies the arguments given to the file into
 * the [magic.db.mysql.read] invocation below.
 */
add:x:+/*/args
   get-nodes:x:@.arguments/*


/*
 * Executes your SQL by transforming the syntax tree
 * into an SQL command.
 */
slots.signal:magic.db.mysql.read
   database:{crm}
   table:roles
   args
   columns
      role
      id


/*
 * Returns the result of the above SQL command.
 */
slots.return-nodes:x:-/*
```

The most important parts above is the content inside of the **[magic.db.mysql.read]** signal. This declares
which database to use, what table to select from, and which **[columns]** to select. If you wish to add or
remove columns, you can simply add or remove one of the children nodes of your **[columns]** node, such as
for instance the above **[id]** node.

## SQL joins and complex SQL

If you want to have complete control over the SQL that is generated, you can choose _"Custom SQL"_ after
having chosen your database. This gives you complete control over the SQL and the parameters your endpoint
accepts. I demonstrate this in the following video.

<div style="margin-left: auto; margin-right: auto; width: 560px;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/sXMmseG8rcM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

The above allows you to create any type of HTTP endpoint, de-reference HTTP arguments, and consume these
in your SQL. Resulting in JSON returned to the client, based upon complex and rich SQL queries. Using
the ideas demonstrated in the above video, gives you 100% perfect control over the SQL your endpoints
are generated with, and which HTTP parameters it can accept. The basic idea is as follows.

* Construct some complex SQL, possibly a join from multiple tables
* Create a _"Custom SQL"_ endpoint, choosing your verb and URL
* Parametrise your endpoint declaratively using the parameters collection
* De-references these parameters in your SQL

Notice, custom SQL endpoints will not result in Angular datagrids automatically created
for you, but they will have a service method in your frontend's Angular code, that you can
use in your frontend code as you see fit.

[Scheduling your C# methods](/scheduler)
